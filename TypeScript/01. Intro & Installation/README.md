# TypeScript Notes

## 1. Introduction to TypeScript

### What is TypeScript?
TypeScript is an open-source language developed by Microsoft. It is a superset of JavaScript, meaning it builds on top of JavaScript by adding optional static typing and class-based object-oriented programming. Any valid JavaScript code is also valid TypeScript code.

### Why use TypeScript?
1.  **Static Typing:** Catches errors early during development (compile-time) rather than at runtime. This leads to fewer bugs and more robust code.
2.  **Improved Readability and Maintainability:** Type annotations make code easier to understand, especially in large codebases with multiple developers.
3.  **Enhanced Tooling:** Provides better autocompletion, navigation, and refactoring capabilities in IDEs (like VS Code) due to type information.
4.  **Scalability:** Ideal for building large-scale applications where code consistency and error prevention are crucial.
5.  **Modern JavaScript Features:** Supports new ECMAScript features (like ES6+) before they are fully adopted by all browsers, as it compiles down to plain JavaScript.

### Key Features
*   **Static Typing:** Define types for variables, function parameters, and return values.
*   **Compilation:** TypeScript code (`.ts` files) is compiled into plain JavaScript (`.js` files) that can run in any browser or Node.js environment.
*   **Classes, Interfaces, Modules:** Provides robust object-oriented programming features.
*   **Generics:** Write reusable code that works with a variety of types.
*   **Decorators:** A special kind of declaration that can be attached to classes, methods, accessors, properties, or parameters.

### Installation & Basic Usage (`tsc`)
1.  **Prerequisites:** Node.js and npm (Node Package Manager) must be installed.
2.  **Install TypeScript globally:**
    ```bash
    npm install -g typescript
    ```
3.  **Compile a TypeScript file:**
    *   Create a file named `hello.ts`:
        ```typescript
        function greet(person: string) {
            return "Hello, " + person;
        }
        let user = "Jane User";
        console.log(greet(user));
        ```
    *   Open your terminal in the directory containing `hello.ts` and run:
        ```bash
        tsc hello.ts
        ```
    *   This will generate a `hello.js` file in the same directory:
        ```javascript
        function greet(person) {
            return "Hello, " + person;
        }
        var user = "Jane User";
        console.log(greet(user));
        ```
    *   You can then run the JavaScript file:
        ```bash
        node hello.js
        ```


## how the TypeScript code compiles and converts to JavaScript and runs?

    TypeScript code (`.ts` files) cannot be directly understood and executed by web browsers or Node.js runtimes. These environments only understand JavaScript. Therefore, TypeScript code needs to be transformed into plain JavaScript code before it can be run. This transformation process is called **compilation** or **transpilation**.

Here's a step-by-step breakdown:

### 1. Writing TypeScript Code (`.ts` files)

You write your application logic using TypeScript syntax, including type annotations, interfaces, classes, etc. For example:

```typescript
// myapp.ts
function greet(name: string): string {
    return `Hello, ${name}!`;
}

let user = "TypeScript Learner";
console.log(greet(user));
```

### 2. Compilation (Transpilation) using the TypeScript Compiler (`tsc`)

The TypeScript Compiler (`tsc`) is the tool responsible for converting your `.ts` files into `.js` files.

*   **Command:** You run the `tsc` command followed by the name of your TypeScript file (or configure `tsconfig.json` for a project).
    ```bash
    tsc myapp.ts
    ```
*   **Process:** The `tsc` compiler reads your `myapp.ts` file. It checks for any type errors or syntax errors based on TypeScript rules. If there are no errors, it then *transpiles* (converts) the TypeScript-specific syntax (like type annotations) into equivalent plain JavaScript code.
*   **Output:** This process generates a new JavaScript file (`.js`) in the same directory (or a specified output directory if configured in `tsconfig.json`).

    For `myapp.ts` above, `tsc` would generate `myapp.js` like this:

    ```javascript
    // myapp.js (generated by tsc)
    "use strict";
    function greet(name) {
        return "Hello, " + name + "!";
    }
    var user = "TypeScript Learner";
    console.log(greet(user));
    ```
    Notice how the type annotations (`: string`) are removed, and modern JavaScript features (like template literals) might be converted to older syntax depending on your `target` setting in `tsconfig.json`.

### 3. Running the JavaScript Code (`.js` files)

Once you have the plain JavaScript file (`.js`), you can run it in any JavaScript runtime environment.

*   **In Node.js:** If you are building a backend application or a command-line tool, you can run the `.js` file using Node.js:
    ```bash
    node myapp.js
    ```
    This will execute the JavaScript code and produce the output (e.g., "Hello, TypeScript Learner!").

*   **In a Web Browser:** If you are building a frontend web application, you would typically include the generated `.js` file in your HTML:
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>TypeScript App</title>
    </head>
    <body>
        <script src="myapp.js"></script>
    </body>
    </html>
    ```
    When the browser loads this HTML, it will fetch and execute `myapp.js`.

### Summary of the Flow:

```
Your TypeScript Code (.ts)
        |
        V
TypeScript Compiler (tsc)
        | (Type Checking & Transpilation)
        V
Plain JavaScript Code (.js)
        |
        V
JavaScript Runtime (Node.js / Browser)
        |
        V
Execution and Output
```

This compilation step is what allows you to write more robust and maintainable code with TypeScript while still being able to run it everywhere JavaScript runs.



## 2. Basic Types

TypeScript supports all JavaScript primitive types and adds several others.

*   **`number`**: For all numeric values (integers, floats).
    ```typescript
    let age: number = 30;
    ```
*   **`string`**: For text data.
    ```typescript
    let name: string = "Alice";
    ```
*   **`boolean`**: For true/false values.
    ```typescript
    let isActive: boolean = true;
    ```
*   **`any`**: A type that can represent any JavaScript value. Use sparingly as it defeats the purpose of static typing.
    ```typescript
    let data: any = 10;
    data = "hello";
    ```
*   **`unknown`**: A safer alternative to `any`. Values of type `unknown` must be type-checked before they can be used.
    ```typescript
    let value: unknown = "hello";
    if (typeof value === "string") {
        console.log(value.toUpperCase());
    }
    ```
*   **`void`**: Used for functions that do not return any value.
    ```typescript
    function logMessage(): void {
        console.log("This function returns nothing.");
    }
    ```
*   **`null` and `undefined`**: Represent the JavaScript primitives `null` and `undefined`. By default, they are subtypes of all other types (unless `strictNullChecks` is enabled).
    ```typescript
    let n: null = null;
    let u: undefined = undefined;
    ```
*   **`never`**: Represents the type of values that never occur. Used for functions that throw an error or never return.
    ```typescript
    function error(message: string): never {
        throw new Error(message);
    }
    ```
*   **Arrays**: Can be defined in two ways.
    ```typescript
    let numbers: number[] = [1, 2, 3];
    let names: Array<string> = ["Alice", "Bob"];
    ```
*   **Tuples**: An array with a fixed number of elements whose types are known, but don't have to be the same.
    ```typescript
    let person: [string, number] = ["Alice", 30];
    ```
*   **Enums**: A way of giving more friendly names to sets of numeric values.
    ```typescript
    enum Color { Red, Green, Blue }
    let c: Color = Color.Green; // c is 1
    enum Status { Success = 200, NotFound = 404 }
    let s: Status = Status.Success; // s is 200
    ```

## 3. Functions

TypeScript allows you to add type annotations to function parameters and return values.

### Type Annotations (parameters, return types)
```typescript
function add(x: number, y: number): number {
    return x + y;
}

let result: number = add(5, 3);

// Function expression
let multiply = function(a: number, b: number): number {
    return a * b;
};
```

### Optional Parameters
Parameters can be made optional by adding a `?` after their name. Optional parameters must come after required parameters.
```typescript
function buildName(firstName: string, lastName?: string): string {
    if (lastName) {
        return firstName + " " + lastName;
    }
    return firstName;
}
console.log(buildName("Bob"));         // "Bob"
console.log(buildName("Bob", "Adams")); // "Bob Adams"
```

### Default Parameters
You can provide a default value for a parameter. If the argument is omitted or `undefined`, the default value is used.
```typescript
function greet(name: string = "Guest"): string {
    return "Hello, " + name;
}
console.log(greet());        // "Hello, Guest"
console.log(greet("Alice")); // "Hello, Alice"
```

### Rest Parameters
Allows a function to accept an indefinite number of arguments as an array.
```typescript
function sumAll(first: number, ...restOfNumbers: number[]): number {
    let total = first;
    for (let num of restOfNumbers) {
        total += num;
    }
    return total;
}
console.log(sumAll(1, 2, 3, 4)); // 10
```

### Function Overloads
Allows you to define multiple function signatures for the same function, providing different ways to call it. The implementation signature must be compatible with all overload signatures.
```typescript
function combine(a: number, b: number): number;
function combine(a: string, b: string): string;
function combine(a: any, b: any): any {
    if (typeof a === 'number' && typeof b === 'number') {
        return a + b;
    }
    if (typeof a === 'string' && typeof b === 'string') {
        return a + b;
    }
    throw new Error("Invalid arguments");
}

console.log(combine(10, 20));    // 30
console.log(combine("Hello", "World")); // "HelloWorld"
// console.log(combine(10, "World")); // Error: No overload matches this call.
```

## 4. Interfaces and Type Aliases

Both interfaces and type aliases are used to define custom types in TypeScript.

### Defining Interfaces
Interfaces define the structure of an object. They are primarily used for type-checking.

*   **Object Types:**
    ```typescript
    interface Person {
        firstName: string;
        lastName: string;
        age?: number; // Optional property
        readonly id: number; // Readonly property
    }

    function printPerson(person: Person) {
        console.log(`${person.firstName} ${person.lastName}`);
        if (person.age) {
            console.log(`Age: ${person.age}`);
        }
    }

    let user: Person = { firstName: "John", lastName: "Doe", id: 123 };
    printPerson(user);
    ```
*   **Function Types:**
    ```typescript
    interface SearchFunc {
        (source: string, subString: string): boolean;
    }

    let mySearch: SearchFunc;
    mySearch = function(source: string, subString: string): boolean {
        let result = source.search(subString);
        return result > -1;
    };
    ```

### Extending Interfaces
Interfaces can extend one or more existing interfaces, inheriting their members.
```typescript
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square: Square = { color: "blue", sideLength: 10 };
```

### Type Aliases vs. Interfaces
*   **Type Aliases (`type`)**: Can define a name for any type, including primitives, union types, tuple types, and object types.
    ```typescript
    type StringOrNumber = string | number;
    type Point = { x: number; y: number; };
    type Callback = (data: string) => void;
    ```
*   **Key Differences:**
    *   **Declaration Merging:** Interfaces can be declared multiple times, and they will merge into a single interface. Type aliases cannot.
        ```typescript
        // Interface merging
        interface Box {
            height: number;
        }
        interface Box {
            width: number;
        }
        let box: Box = { height: 10, width: 20 }; // Works

        // Type alias cannot be merged
        // type BoxType = { height: number; };
        // type BoxType = { width: number; }; // Error: Duplicate identifier
        ```
    *   **Extending/Implementing:** Interfaces can be extended by other interfaces and implemented by classes. Type aliases can only be extended by other type aliases (using intersection types) and cannot be implemented by classes directly (unless they define an object shape).
    *   **Use Cases:**
        *   Use **Interfaces** for defining the shape of objects, especially when you expect them to be extended or implemented by classes.
        *   Use **Type Aliases** for defining names for primitive types, union types, tuple types, or when you need to define a type that is not an object shape (e.g., `type ID = string | number;`).

## 5. Classes

TypeScript supports classes with features like constructors, properties, methods, and access modifiers, similar to other object-oriented languages.

### Class Declaration
```typescript
class Greeter {
    greeting: string; // Property

    constructor(message: string) { // Constructor
        this.greeting = message;
    }

    greet(): string { // Method
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
console.log(greeter.greet()); // "Hello, world"
```

### Properties and Methods
*   **Properties:** Variables declared within a class.
*   **Methods:** Functions declared within a class.

### Access Modifiers (public, private, protected)
*   **`public` (default):** Members are accessible from anywhere.
*   **`private`:** Members are only accessible from within the class they are declared in.
*   **`protected`:** Members are accessible from within the class and by instances of derived classes.

```typescript
class Animal {
    public name: string;
    private age: number;
    protected species: string;

    constructor(name: string, age: number, species: string) {
        this.name = name;
        this.age = age;
        this.species = species;
    }

    public getAge(): number {
        return this.age;
    }
}

class Dog extends Animal {
    constructor(name: string, age: number) {
        super(name, age, "Canine");
    }

    bark() {
        console.log(`${this.name} barks! It's a ${this.species}.`); // Can access protected 'species'
        // console.log(this.age); // Error: Property 'age' is private
    }
}

let myDog = new Dog("Buddy", 5);
console.log(myDog.name); // "Buddy"
console.log(myDog.getAge()); // 5
myDog.bark();
```

### Constructors
A special method for creating and initializing an object created with a class.

### Inheritance
Classes can extend other classes, inheriting their properties and methods. Use the `extends` keyword.
```typescript
class Vehicle {
    constructor(public brand: string) {}
    move() {
        console.log(`${this.brand} is moving.`);
    }
}

class Car extends Vehicle {
    constructor(brand: string, public model: string) {
        super(brand); // Call the parent class constructor
    }
    drive() {
        console.log(`${this.brand} ${this.model} is driving.`);
    }
}

let myCar = new Car("Toyota", "Camry");
myCar.move();  // "Toyota is moving."
myCar.drive(); // "Toyota Camry is driving."
```

### Abstract Classes
Abstract classes are base classes from which other classes may be derived. They cannot be instantiated directly and can contain abstract methods (methods without an implementation) that must be implemented by derived classes.
```typescript
abstract class Department {
    constructor(public name: string) {}

    printName(): void {
        console.log("Department name: " + this.name);
    }

    abstract describe(): void; // Must be implemented in derived classes
}

class AccountingDepartment extends Department {
    constructor() {
        super("Accounting and Auditing"); // Call the parent constructor
    }

    describe(): void {
        console.log("Manages financial operations.");
    }
}

// let department = new Department(); // Error: Cannot create an instance of an abstract class.
let accounting = new AccountingDepartment();
accounting.printName(); // "Department name: Accounting and Auditing"
accounting.describe();  // "Manages financial operations."
```

## 6. Generics

Generics provide a way to create reusable components that can work with a variety of types rather than a single one. They allow you to write flexible and type-safe code.

### What are Generics?
Generics use type variables (like `T`, `U`, `K`, `V`, etc.) as placeholders for actual types.

### Generic Functions
```typescript
function identity<T>(arg: T): T {
    return arg;
}

let output1 = identity<string>("myString"); // Type argument explicitly provided
let output2 = identity(100);              // Type argument inferred (number)
```

### Generic Interfaces
```typescript
interface GenericIdentityFn<T> {
    (arg: T): T;
}

function identityFn<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn<number> = identityFn;
console.log(myIdentity(5)); // 5
```

### Generic Classes
```typescript
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;

    constructor(zero: T, adder: (x: T, y: T) => T) {
        this.zeroValue = zero;
        this.add = adder;
    }
}

let myGenericNumber = new GenericNumber<number>(0, (x, y) => x + y);
console.log(myGenericNumber.add(5, 10)); // 15

let stringConcatenator = new GenericNumber<string>("", (x, y) => x + y);
console.log(stringConcatenator.add("Hello", "World")); // "HelloWorld"
```

### Generic Constraints
You can restrict the types that can be used with a generic by applying constraints.
```typescript
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length); // Now we know it has a .length property
    return arg;
}

// loggingIdentity(3); // Error: Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.
loggingIdentity({ length: 10, value: 3 }); // OK
```

## 7. Advanced Types

TypeScript offers powerful features for working with complex type scenarios.

### Union Types
A type that can be one of several types. Use the `|` (pipe) symbol.
```typescript
function printId(id: number | string) {
    console.log("Your ID is: " + id);
}
printId(101);
printId("202");
// printId(true); // Error
```

### Intersection Types
Combines multiple types into one. An object of an intersection type will have all members of all types. Use the `&` (ampersand) symbol.
```typescript
interface Draggable {
    drag(): void;
}

interface Resizable {
    resize(): void;
}

type UIWidget = Draggable & Resizable;

let widget: UIWidget = {
    drag: () => console.log("Dragging..."),
    resize: () => console.log("Resizing...")
};
widget.drag();
widget.resize();
```

### Type Guards
Mechanisms to narrow down the type of a variable within a certain scope.

*   **`typeof` type guard:** For primitive types (`string`, `number`, `boolean`, `symbol`, `bigint`, `undefined`, `object`, `function`).
    ```typescript
    function printLength(x: string | number) {
        if (typeof x === "string") {
            console.log(x.length); // x is string here
        } else {
            console.log(x); // x is number here
        }
    }
    ```
*   **`instanceof` type guard:** For classes.
    ```typescript
    class Dog { bark() { console.log("Woof!"); } }
    class Cat { meow() { console.log("Meow!"); } }

    function animalSound(animal: Dog | Cat) {
        if (animal instanceof Dog) {
            animal.bark(); // animal is Dog here
        } else {
            animal.meow(); // animal is Cat here
        }
    }
    ```
*   **`in` operator type guard:** Checks if a property exists on an object.
    ```typescript
    interface Car { drive: () => void; }
    interface Plane { fly: () => void; }

    function move(vehicle: Car | Plane) {
        if ("drive" in vehicle) {
            vehicle.drive();
        } else {
            vehicle.fly();
        }
    }
    ```
*   **User-Defined Type Guards:** Functions that return a type predicate (`parameterName is Type`).
    ```typescript
    function isFish(pet: Fish | Bird): pet is Fish {
        return (pet as Fish).swim !== undefined;
    }
    ```

### Literal Types
Allows you to define types that are exact values (literals).
```typescript
type Direction = "up" | "down" | "left" | "right";
let move: Direction = "up";
// let invalidMove: Direction = "forward"; // Error
```

### Nullable Types (`strictNullChecks`)
When `strictNullChecks` is enabled in `tsconfig.json`, `null` and `undefined` are not assignable to other types by default. You must explicitly allow them using union types.
```typescript
let s: string = "hello";
// s = null; // Error if strictNullChecks is true

let sOrNull: string | null = "hello";
sOrNull = null; // OK
```

### Type Assertions
Tells the compiler "trust me, I know what I'm doing." It's a way to override TypeScript's type inference.

*   **Angle-bracket syntax:**
    ```typescript
    let someValue: any = "this is a string";
    let strLength: number = (<string>someValue).length;
    ```
*   **`as` syntax (preferred in JSX/TSX):**
    ```typescript
    let anotherValue: any = "this is another string";
    let anotherStrLength: number = (anotherValue as string).length;
    ```
    **Caution:** Type assertions do not perform any runtime checks. They are purely compile-time constructs.

## 8. Modules

Modules help organize code into separate, reusable units. TypeScript supports both CommonJS and ES Modules syntax.

### Exporting and Importing (ES Modules syntax)
*   **Exporting:** Use `export` keyword.
    ```typescript
    // math.ts
    export function add(x: number, y: number): number {
        return x + y;
    }
    export const PI = 3.14159;
    ```
*   **Importing:** Use `import` keyword.
    ```typescript
    // app.ts
    import { add, PI } from "./math"; // Relative path

    console.log(add(5, 2)); // 7
    console.log(PI);        // 3.14159
    ```
*   **Default Exports:** One per module.
    ```typescript
    // greeter.ts
    export default class Greeter {
        greet() {
            return "Hello!";
        }
    }

    // app.ts
    import MyGreeter from "./greeter"; // No curly braces for default import
    let greeter = new MyGreeter();
    console.log(greeter.greet());
    ```
*   **Importing everything as a single object:**
    ```typescript
    // app.ts
    import * as MathFunctions from "./math";
    console.log(MathFunctions.add(10, 5));
    ```

## 9. `tsconfig.json` Configuration

The `tsconfig.json` file in a TypeScript project specifies the root files and the compiler options required to compile the project.

To create a `tsconfig.json` file in your project root:
```bash
tsc --init
```

### Common Compiler Options

*   **`target`**: Specifies the ECMAScript target version for the generated JavaScript code.
    *   `"ES5"` (default), `"ES6"`/`"ES2015"`, `"ES2016"`, `"ES2017"`, `"ES2018"`, `"ES2019"`, `"ES2020"`, `"ES2021"`, `"ES2022"`, `"ESNext"`.
    *   Example: `"target": "ES2018"`

*   **`module`**: Specifies the module code generation.
    *   `"CommonJS"` (default for Node.js), `"ES6"`/`"ES2015"`, `"ESNext"`, `"AMD"`, `"UMD"`, `"System"`.
    *   Example: `"module": "CommonJS"`

*   **`rootDir`**: Specifies the root directory of input files.
    *   Example: `"rootDir": "./src"`

*   **`outDir`**: Specifies the output directory for compiled JavaScript files.
    *   Example: `"outDir": "./dist"`

*   **`strict`**: Enables a broad range of strict type-checking options. Highly recommended for new projects.
    *   `true` or `false`.
    *   Example: `"strict": true` (enables `noImplicitAny`, `strictNullChecks`, `strictFunctionTypes`, `strictPropertyInitialization`, `noImplicitThis`, `alwaysStrict`, `strictBindCallApply`)

*   **`esModuleInterop`**: Enables compatibility with CommonJS modules when importing ES Modules.
    *   `true` or `false`.
    *   Example: `"esModuleInterop": true`

*   **`skipLibCheck`**: Skips type checking of all declaration files (`.d.ts`). Useful for speeding up compilation in large projects with many third-party libraries.
    *   `true` or `false`.
    *   Example: `"skipLibCheck": true`

*   **`forceConsistentCasingInFileNames`**: Disallow inconsistently-cased references to the same file.
    *   `true` or `false`.
    *   Example: `"forceConsistentCasingInFileNames": true`

*   **`declaration`**: Generates corresponding `.d.ts` (declaration) files.
    *   `true` or `false`.
    *   Example: `"declaration": true`

*   **`sourceMap`**: Generates corresponding `.map` files for debugging.
    *   `true` or `false`.
    *   Example: `"sourceMap": true`

*   **`include`**: An array of glob patterns or file paths to include in the compilation.
    *   Example: `"include": ["src/**/*.ts"]`

*   **`exclude`**: An array of glob patterns or file paths to exclude from the compilation.
    *   Example: `"exclude": ["node_modules", "dist"]`

This `tsconfig.json` file provides a good starting point for most TypeScript projects.
